---
title: "Swiftで非同期処理の結果を受け取る方法 #その1"
emoji: "🕊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["swift", "combine", "rxswift", "デザインパターン", "非同期処理"]
published: true
---

## 非同期処理って難しい

プログラム処理のパターンを時間軸でざっくり分けると、同期処理と非同期処理の 2 パターンがあります。同期処理は上から順にコードが実行されていくので、直感的ですよね。
ですが非同期処理の話になると、途端に、`コールバック`やら`Reactive Programming`やら難しい単語がたくさん出てきて、とっつきにくいと私は感じてしまいます。

非同期処理の理解を難しくしているのは、処理の中身ではなく、処理結果の受け取り方がパターンによって様々だからです。パターン毎の違いと使い所を知っていれば、非同期処理にへの恐怖感も拭いやすいです。

## 処理結果の受け取り方が異なるパターンは全部で 7 つ

その中でも大きくオブザーバーパターンとそれ以外に分けられます。

| 受け取り方のパターン                                                                                                                                             | カテゴリ                                  | 可読性                                                          | 使い所                                                                                                      |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------- | :-------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------- |
| [**クロージャ**](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%A8%E3%81%AF) | Swift 固有の言語機能                      | ○<br>コールバックで結果を返すのでネストが増える                 | ・async / await を使えない環境かつ、KVO や NotificationCenter を使うのは大袈裟な時                          |
| **デリゲート**                                                                                                                                                   | デリゲートパターン                        | △<br>実装がどのタイミングで実行されるか知る必要あり             | ・`UITableViewDelegate`のメソッド等、UIKit のメソッドを使う時<br>・実装の一部を別オブジェクトに委譲したい時 |
| [**async / await**](https://developer.apple.com/documentation/swift/concurrency#asynchronous-sequences)                                                          | Swift Concurrency                         | ◎<br>非同期処理を手続き型のように書けるので、ネストが抑えられる | ・iOS 15 以上の時                                                                                           |
| [**KVO (Key-Value Observing)**](https://developer.apple.com/documentation/swift/using-key-value-observing-in-swift)                                              | オブザーバーパターン                      | △<br>依存関係が分かり辛い                                       | ・RxSwift や Combine を使えない環境だがオブジェクト購読を監視したい時                                       |
| [**NotificationCenter**](https://developer.apple.com/documentation/foundation/notificationcenter)                                                                | オブザーバーパターン                      | △<br>依存関係が分かり辛い                                       | ・RxSwift や Combine を使えない環境だがオブジェクト購読を監視したい時                                       |
| [**RxSwift**](https://github.com/ReactiveX/RxSwift)                                                                                                              | オブザーバーパターン<br>外部ライブラリ    | ◎<br>非同期処理を同期処理ぽく書ける                             | ・オブジェクト購読を監視 / 操作したい時<br>・iOS 8~12 の時                                                  |
| [**Combine**](https://developer.apple.com/documentation/combine)                                                                                                 | オブザーバーパターン<br>Swift Concurrency | ◎<br>RxSwift よりもスッキリ書ける                               | ・オブジェクト購読を監視 / 操作したい時<br>・iOS 13 以上の時                                                |

これらのパターンを理解できると、他者のコードを参考にする時、そのコードは何故良いかが分かるので、自分の書くコードに自信が持てます。
では、一番上の **クロージャ** パターンから書き方を見てみましょう。

## クロージャ パターン

```swift
// 非同期処理をするメソッド
/// ランチを食べる(食事時間を返す)
func eatLunch(@escaping finishEatingNotifier: ((Int) -> Void)?) {
  let timeToEat: Int = Int.random(in: 1...5)
  sleep(timeToEat)

  finishEatingNotifier(timeToEat)
}

// 処理結果を受け取る側
/// 食事時間を上司に報告する
eatLunch { result in
    report(result, to: boss)
}
```

`eatLanch` というメソッドでの最後の処理で `finishEatingNotifier` が、`timeToEat` という結果の値付きで、`eatLanch`メソッドの引数として渡されています。
一方 `eatLanch`メソッドを呼び出す側では、メソッド名に続きクロージャが記述されています。そのクロージャ内で、`eatLanch` メソッドで引数だった`finishEatingNotifier`に渡された結果の値である`result(=timeToEat)`が、今度はクロージャ内の引数として、`report`メソッドに使われている事が分かります。

ここでの主役は [トレイリングクロージャ](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3) と [@escaping](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#escaping) です。

**トレイリングクロージャ**とは、メソッドの引数のクロージャを、`()`の外に記述できる記法です。引数の最後が、クロージャ型の場合のみ書けます。そして、引数がクロージャのみなら、呼び出し元メソッドの`()`を省略できます。
**escaping 属性**とは、メソッドに引数として渡されたクロージャが、スコープから抜けても存在しうる場合につける属性です。この一文だけだと分かり辛いですが、つまりは`@escaping` をつけないと、メソッドがクロージャを引数に持っていても、メソッドの外では処理を実行できないという事です。
上のコードなら、`@escaping`をつけないと `eatLunch` メソッドにトレイリングクロージャを記載できないし、 `result` も引数として使えない、という事です。

この 2 つの Swift 特有の記法を組み合わせると、上記のコードのように、
**`eatLunch` メソッドによる非同期処理の実行 → `report` メソッドの実行**
という順序が必ず守られるようになります。

しかし、以下のように非同期処理の流れが複数組み合わさってくると、クロージャがネストしてしまうので、クロージャ毎のスコープが分かり辛くなってしまい可読性を下げます。

```swift
/// 食事時間を上司に報告する
eatLunch { result in
    /// 上司にその結果を報告する(非同期)
    report(result, to: boss) { nextTask in
        /// 報告した際に指示された、午後の分の仕事に取り掛かる(非同期)
        work(on: nextTask) { result in
            switch result {
            case .success:
                takeBreak()

            case .failure(let reason):
                askBoss(with: reason)
            }
        }
    }
}
```

クロージャパターンは、async / await が使えない iOS 14 以下でも使えます。ネストが生まれる = メソッド間に依存関係があるという事なので、依存関係にあるメソッド同士を 1 つのメソッドに統合する等して、ネストを解消しながらクロージャパターンを使っていきましょう。

次回は **デリゲート** パターンについて触れていければと思います。🕊

---

#### 出典

- [Swift の始め方](https://swift.codelly.dev)
