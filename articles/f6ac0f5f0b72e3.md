---
title: "Swiftで非同期処理を順番に実行したい　#その1"
emoji: "🕊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["swift", "コールバック", "rxswift", "非同期処理"]
published: true
---

## 複数の非同期処理をどうやって順番に実行するか

プログラム処理のパターンを時間軸で大別すると、同期処理と非同期処理の 2 つがあります。同期処理は上から順にメソッドを並べるだけで、上から順にコードが実行されていくので、直感的ですよね。
ですが非同期処理はそうはいきません。非同期処理の実装にはいくつか手法があるのですが、複数の手法を一挙に網羅した記事がまだ多くなく、手法毎の比較がしにくいのではと思っています。
手法毎の違いと使い所を理解すれば、なぜコールバックは一般的に良くないとされ、Combine や Swift Concurrency の 1 つの機能である async / await が良しとされるのか、より納得できると思います。

## 処理の受け取り方が異なるパターンは大きく分けて 4 つ

大別すると、コールバックによるネストを生むパターンと、そうではないパターンです。

| 受け取り方のパターン                                                                                                                                     | 特徴、長所                                                                                                                                                                                   | 可読性                                                                    | 使い所                                                                                         |
| -------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| コールバック                                                                                                                                             | ・Swift の言語機能である[クロージャ](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%A8%E3%81%AF)を用いる | △<br>直列実行に伴いネストが増えるので、所謂コールバック地獄が生まれやすい | ・Promise や RxSwift 等の後述する手法を使うのは大袈裟で、非同期処理を 1 つだけ直列実行したい時 |
| [**Promise**](https://github.com/google/promises)                                                                                                        | ・RxSwift に比べコールバックや GCD 同様に軽量かつシンプル<br> ・非同期処理を手続き型のように書ける                                                                                           | ○<br>直列実行でもネストが抑えられる                                       | ・14 以下の時                                                                                  |
| [**Hydra**](https://github.com/malcommac/Hydra), [**async / await**](https://developer.apple.com/documentation/swift/concurrency#asynchronous-sequences) | ・非同期処理を手続き型のように書ける                                                                                                                                                         | ◎<br>Promise よりもさらにシンプル                                         | ・iOS 15 以上なら async / await<br>・14 以下でも async / await ライクに書きたいなら Hydra      |
| [**RxSwift**](https://github.com/ReactiveX/RxSwift), [**Combine**](https://developer.apple.com/documentation/combine)                                    | ・[オブザーバパターン](https://ja.wikipedia.org/wiki/Observer_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)<br>・非同期処理を手続き型のように書ける上に、イベント操作がしやすい                      | ○ ~ ◎<br>時系列順にメソッドチェーンができるのでネストが抑えられる         | ・イベントを監視、操作したい時<br>・iOS 8~12 なら RxSwift<br>・iOS 13 以上なら Combine         |

なお、非同期処理の方法としては他に Apple が提供する [GCD(Grand Central Dispatch)](https://developer.apple.com/documentation/DISPATCH) がありますが、GCD による処理の受け取り方はコールバック パターンに当てはまります。

表を眺めてもらうとわかる通り、コールバック パターン以外の下 3 つのパターンはどれも、複数の非同期処理を順番に実行した際に、ネストが深くならないよう抑える手法によるものです。

では、一番上の**コールバック パターン**から詳しく見てみましょう。

## コールバック パターン

```swift
// 非同期処理をするメソッド
/// ランチを食べる(食事時間を返す)
func eatLunch(@escaping finishEatingNotifier: ((Int) -> Void)?) {
  let timeToEat: Int = Int.random(in: 1...5)
  sleep(timeToEat)

  finishEatingNotifier(timeToEat)
}

// 処理結果を受け取る側
/// 食事時間を上司に報告する
eatLunch { result in
    report(result, to: boss)
}
```

`eatLanch` というメソッドでの最後の処理で `finishEatingNotifier` が、`timeToEat` という結果の値付きで、`eatLanch`メソッドの引数として渡されています。
一方 `eatLanch`メソッドを呼び出す側では、メソッド名に続きクロージャが記述されています。そのクロージャ内で、`eatLanch` メソッドで引数だった`finishEatingNotifier`に渡された結果の値である`result(=timeToEat)`が、今度はクロージャ内の引数として、`report`メソッドに使われている事が分かります。

ここでの主役は [トレイリングクロージャ](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3) と [@escaping](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#escaping) です。

> **トレイリングクロージャ**とは、メソッドの引数のクロージャを、`()`の外に記述できる記法です。引数の最後が、クロージャ型の場合のみ書けます。そして、引数がクロージャのみなら、呼び出し元メソッドの`()`を省略できます。

> **escaping 属性**とは、メソッドに引数として渡されたクロージャが、スコープから抜けても存在しうる場合につける属性です。

この一文だけだと分かりづらいですが、つまりは`@escaping` をつけないと、メソッドがクロージャを引数に持っていても、メソッドの外では処理を実行できないという事です。
上のコードなら、`@escaping`をつけないと `eatLunch` メソッドにトレイリングクロージャを記載できないし、 `result` も引数として使えない、という事です。

この 2 つの Swift 特有の記法を組み合わせると、上記のコードのように、
**`eatLunch` メソッドによる非同期処理の実行 → `report` メソッドの実行**
という順序が必ず守られるようになります。

しかし、以下のように非同期処理の直列実行の数が増えてくると、クロージャのネストが繰り返されてしまうので、クロージャ毎のスコープが分かりづらくなってしまい可読性を下げます。
いわゆる**コールバック地獄**というやつです。

```swift
/// 食事時間を上司に報告する
eatLunch { result in
    /// 上司にその結果を報告する(非同期)
    report(result, to: boss) { nextTask in
        /// 報告した際に指示された、午後の分の仕事に取り掛かる(非同期)
        work(on: nextTask) { result in
            switch result {
            case .success:
                takeBreak()

            case .failure(let reason):
                askBoss(with: reason)
            }
        }
    }
}
```

コールバック パターンは、最もシンプルな書き方です。他の手法を使うまでもない場面では効果的なので、コールバック地獄にならないよう意識しながら実装しましょう。

次回は **Promise** パターンで、このコールバック地獄を回避していく方法について触れていければと思います。🕊

---

#### 出典

- [Swift の始め方](https://swift.codelly.dev)
- [stmn, inc. Tech Blog](https://tech.stmn.co.jp/entry/tech/6649)
