---
title: "Swiftで非同期処理の結果を受け取る方法 #その1"
emoji: "🕊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics:
  [
    "swift",
    "非同期処理",
    "デザインパターン",
    "RxSwift",
    "Combine",
    "async/await",
  ]
published: true
---

## 非同期処理って難しい

プログラム処理のパターンを時間軸でざっくり分けると、同期処理と非同期処理の 2 パターンがあります。同期処理は上から順にコードが実行されていくので、直感的ですよね。
では非同期処理はどうでしょうか。非同期処理の話になると、途端に、`コールバック`やら`Reactive Programming`やら難しい単語がたくさん出てきて、とっつきにくい内容だと私は感じてしまいます。
非同期処理の理解を難しくしているのは、処理の中身ではなく、その結果の受け取り方がパターンによって様々だからです。パターン毎の処理結果の受け取り方の違いと、長所・短所を知っていれば、非同期処理に対する恐怖感も拭いやすいです。

## パターンは全部で 7 つ

コードを書く立場からすると、Combine や async/await が使える環境なら、使うのがオススメというのが私個人の考えです。

| パターン                    | カテゴリ                                  | 可読性                                                          | 使い所                                                                                                               |
| :-------------------------- | :---------------------------------------- | :-------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------- |
| `クロージャ`                | Swift の言語機能                          | ○<br>コールバックで結果を返すのでネストが増える                 | - RxSwift や Combine を使うのは少々大袈裟に感じる時                                                                  |
| `デリゲート`                | デリゲートパターン                        | △<br>実装がどのタイミングで実行されるか知る必要あり             | - `UITableViewDelegate`のメソッド等、UIKit のメソッドを使う時<br>- 実装の一部を別オブジェクトに委譲したい時          |
| `KVO (Key-Value Observing)` | オブザーバーパターン                      | ○<br>依存関係がやや分かり辛い                                   | - アプリのサポート範囲に iOS 12 を含む時、かつ 同じオブジェクト内で値の変更を検知して何かしたい(=購読を監視したい)時 |
| `NotificationCenter`        | オブザーバーパターン                      | △<br>依存関係が分かり辛い                                       | - アプリのどこからでも、購読を監視したい時                                                                           |
| `RxSwift`                   | オブザーバーパターン<br>外部ライブラリ    | ◎<br>非同期処理を同期処理ぽく書ける                             | - 購読を監視したい時 <br> - アプリのサポート下限範囲が iOS 8~12 の時                                                 |
| `Combine`                   | オブザーバーパターン<br>Swift Concurrency | ◎<br>RxSwift よりもスッキリ書ける                               | - 購読を監視したい時<br> - アプリのサポート下限範囲が iOS 13 以上の時                                                |
| `async / await`             | Swift Concurrency                         | ◎<br>非同期処理を手続き型のように書けるので、ネストが抑えられる | - アプリのサポート下限範囲が iOS 15 以上の時                                                                         |

コードを書く立場だけでなく、読む立場に立つ事で、今書いているコードが何故良いか理解でき、自分の書くコードに自信が持てます。
では、コードを読む立場に立って、まずは一番上の escaping パターンから書き方を見てみましょう。

## `クロージャ` パターン

```swift
// 非同期処理をするメソッド
/// ランチを食べる(食事時間を返す)
func eatLunch(@escaping finishEatingNotifier: ((Int) -> Void)?) {
  let timeToEat: Int = Int.random(in: 1...5)
  sleep(timeToEat)

  finishEatingNotifier(timeToEat)
}

// 処理結果を受け取る側
/// 食事時間を上司に報告する
eatLunch { result in
    report(result, to: boss)
}
```

`eatLanch` というメソッド内での処理の最後に `finishEatingNotifier` が、`timeToEat` という結果の値付きで、メソッドの引数として渡されています。
一方 `eatLanch`メソッドを呼び出す側では、メソッドの後ろにクロージャが記述されています。そのクロージャの中で、`eatLanch` メソッドで引数だった`finishEatingNotifier`に渡された結果の値である`result(=timeToEat)`が、今度はクロージャ内の引数として、`report`メソッドに使われている事が分かります。

今回の主役は [トレイリングクロージャ](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3) と [@escaping](https://swift.codelly.dev/guide/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3/#escaping) です。

**トレイリングクロージャ**とは、メソッドの引数のクロージャを、`()`の外に記述できる記法です。引数の最後が、クロージャ型の場合のみ書けます。そして、引数がクロージャのみなら、呼び出し元メソッドの`()`を省略できます。
**escaping 属性**とは、メソッドに引数として渡されたクロージャが、スコープから抜けても存在しうる場合につける属性です。これだけだと分かり辛いですが、`@escaping` をつけないと、クロージャはメソッドの外で処理を実行できないという事です。
上のコードなら、`@escaping`をつけないと `result` が引数として使えない、という事です。

この 2 つの Swift 特有の記法を組み合わせると、上記のコードのように、
**`eatLunch` メソッドによる非同期処理の実行 → `report` メソッドの実行**
という順序が必ず守られるようになります。

次回は `デリゲート` パターンについて触れていければと思います。🕊

---

#### 出典

- [Swift の始め方](https://swift.codelly.dev)
