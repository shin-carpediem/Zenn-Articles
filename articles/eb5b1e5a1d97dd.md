---
title: "動的型付け言語こそ型を書こう"
emoji: "🍴"
type: "tech"
topics: ["動的型付け言語", "静的型付け言語"]
published: true
---

## なぜ型を書くべきか

予期しない値が混入して、アプリケーションがクラッシュしてしまうのを避けるためです。

動的型付け言語である Python で書かれた以下のコードを見てください。

```python
number_list = ["0", "1", "2", 3, "4"]

for number in number_list:
    int(number)
```

このコードは、number が 3 の時に、`str` 型を `int` 型に変換する`int()`関数の引数に str 型ではない型が渡されるので、エラーとなります。アプリケーションの場合はクラッシュに繋がります。

静的型付け言語は、コンパイル時に変数の型が決まるので、アプリを実行する前に型の不一致による上述したエラーを検出できます。
一方 Python のような動的型付け言語は、コンパイル時よりも後、プログラム実行時に変数の型が決まります。
なので、プログラムを実行するまで、上述したエラーに仕組みの側からは気づけません。

つまり、動的型付け言語の方が、アプリケーションがクラッシュしてしまうリスクが高いと言えます。

## 動的型付け言語で発生する『型の予想』

一般にプログラマは、コードを書く時間よりもコードを読む時間の方が長いとされます。
自分の書いたコードでも、半年も経てば、他者が書いたコードのように見えます。

自分がコードを書いている時は、自分が定義した変数に、何が代入されうるのかを想定できています。
しかし、他者が定義した変数にどんな値が入りうるかは、動的型付け言語の場合、型が明記されていなければ、上流のコードを辿って行くしかありません。
それが何十行、何百行にもなると、**途中でコードを読むのをやめて、型を予想するようになります。**
このような予想が外れた時に、前段であげたコード例のようなバグを産むきっかけとなります。

このリスクを下げるために、動的型付け言語でも、しっかりと型の定義をすべきなのです。

## クラッシュリスクを下げる型の書き方

### 全ての変数、関数の引数・戻り値の型を明記しましょう

原則、全て型を明記していくことをお勧めします。
Python でコード例を示していきます。

### 変数

```python
number_list: list[str] = ["0", "1", "2", "3", "4"]
```

値に Null が入りうる場合は、オプショナル型としてきちんと明記しましょう。

```python
number_list: list[str | None] = ["0", "1", "2", "3", None, "4"]
```

:::message
上記は Python 3.10 で可能になった書き方です。
Python 3.9 までは以下のように書く必要があります。

```python
from typing import Optional

number_list: list[Optional[str]] = ["0", "1", "2", "3", None, "4"]
```

:::

### 関数

関数の場合も同様です。引数、戻り値の型を漏れなく明記しましょう。

```python
def number_appended_list(number: str) -> list[str | None]:
    return self.number_list.append(number)
```

関数の戻り値がない場合は、明示的に`None`[^1]としてあげると、書き忘れではないことを読み手に伝える事ができ、ベターです。
[^1]: ここでは`None`は Java や Swift の`Void`型と同じ扱いになります。

```python
def append_number_to_list(number: str) -> None:
    self.number_list.append(number)
```

### タイプエイリアス

型が複雑な場合は、型の別名(`タイプエイリアス`)定義するのも手です。
ただし個人的には、Null とその他の型とは分けて定義した方が良いと考えています。
Null は 1 段階、型の抽象度が上がるからです。
いずれにしても、型は丁寧に明記していきましょう。

```python
number_type = str | int | float

number_list: list[snumber_type | None] = [0, "1", "2", "3", None, "4", 4.5]
```

:::message
Python 3.9 までの書き方

```python
from typing import Union

number_type = Union[str, int, float]

number_list: list[Optional[snumber_type]] = [0, "1", "2", "3", None, "4", 4.5]
```

:::

## +α でクラッシュリスクを減らす方法

上述したように全ての変数、関数の引数・戻り値の型を明記すれば、コードの読み手が型の予想を強いられる頻度は、かなり減るはずです。
しかし、型を書くだけでなく、以下のような + α を行う事で、さらにコードが読みやすくなり、クラッシュリスクを減らせます。

- 関数に 2 つ以上の引数を代入する際に、引数名を省略しない
- 変数、関数の用途をドキュメントコメントで明記する
- コンパイル時か、それよりも前に、型走査する機能を IDE に入れる

## 関数に 2 つ以上の引数を代入する際に、引数名を省略しない

以下のような関数があったとします。

```python
def append_list_and_print(number: str, additional_message: str) -> None:
    self.number_list.append(number)
    print(f"One number has appneded. {additional_message}")
```

引数 `number` は list に追加され、引数 `additional_message` は、`print` 関数で出力される、という処理です。
この関数は引数の型がどちらも `str` 型です。
このような場合に、以下のような引数の渡し方をしたらどうなるでしょうか。

```python
append_list_and_print("5 has appended.", "5")
```

渡すべき引数の順番が逆になっているので、引数`number`に`"5 has appended."`が渡され、`additional_message`に`"5"`が渡されてしまいますね。

同じ型の引数名を 2 つ以上省略した場合、IDE が検知してエラーを出す事もありますが、100%ではありません。そのような場合、意図しない値が数に渡されてしまい、バグに繋がります。

引数名は省略せず、明記するようにしましょう。

```python
append_list_and_print(
    number="5",
    additional_message="5 has appended.",
)
```

## 変数、関数の用途をドキュメントコメントで明記する

## コンパイル時か、それよりも前に、型走査する機能を IDE に入れる

静的型付け言語の一つ swift には、[Xcode](https://developer.apple.com/jp/xcode/) という専用の統合開発環境(IDE)があり、コンパイルよりもさらに前、コードを書いた瞬間に型走査が走り、型の不一致があればエラーを吐き出します。

動的型付け言語には型がないため、デフォルトでは型走査機能はありません。
しかし、以下のような型走査ライブラリを用いれば、動的型付け言語であっても、プログラム実行時よりも前に、型の不一致に気付けます。

- Python
  - [mypy](https://github.com/python/mypy)
